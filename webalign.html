<!DOCTYPE html>
<!--
To change this license header, choose License Headers in Project Properties.
To change this template file, choose Tools | Templates
and open the template in the editor.
-->
<html>
    <head>
        <title>WebAlign v0.1</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <style>
            html,body{
                height: 100%;
                margin: 0;
                overflow: hidden;
            }
            body{
                background: purple;
                padding: 0;
            }
            div{
                position: absolute;
            }
            #controls{
                /*background: red;*/
                background: white;
            }
            #hsiz{
                cursor: ew-resize;
            }
            #main{
                background: white;
                overflow: hidden;
            }
            .hsep{
                width: 10px;
                background: grey;
            }
            #navi{
                background: green;
                overflow: hidden;
            }
            #vsiz{
                height: 10px;
                background: grey;
                cursor: ns-resize;
            }
            #filmstrip{
                background: white;
                height: 128px;
                overflow: hidden;
            }
            canvas{
                margin: 0;
                padding: 0;
                border: 0;
            }
        </style>
        <script src="slicer.js"></script>
        <script src="math.js"></script>
        <!--<script src="dzimage.js"></script>-->
        <script>
            let args=new Map();
            let atlas={xdim:1,ydim:1,zdim:1};
            let series;
            let images=[];
            let fsw=0;
            let ready=false;
            async function startup(){
                let start=Date.now();
                window.addEventListener("resize",resize);
                resize();
                for(let arg of location.search.substring(1).split("&")){
                    let pair=arg.split("=");
                    args.set(pair[0],pair.length===2?pair[1]:true);
                }
                let download=await fetch("bucket.php?filename=" + args.get("filename")).then(response=>response.json());
                series=await fetch(download.url).then(response=>response.json());
                console.log(Date.now()-start,"Got series");
                /*let*/ atlas=new Promise(resolve=>new Worker("getlas.js?"+series.atlas)
                        .onmessage=event=>resolve(event.data));
//                let worker=new Worker("getlas.js?"+args.get("atlas"));

                for(let section of series.sections){
                    // {"name":"hbp-00167-641_2001_2561_s001.tif","width":22500,"height":17500,"tilesize":254,"overlap":1,"format":"png"}
                    let fullname=section.name;
                    let pos=fullname.lastIndexOf(".");
                    let name=fullname.substring(0,pos);

                    let image={
                        ...section,base:series.container+"/"+fullname+"/"+name+"_files/",
                    };
                    
                    let w=image.width;
                    let h=image.height;
                    
                    image.fsx=fsw;
                    if(w>h){
                        image.fsw=128;
                        image.fsh=h*128/w;
                        image.fsy=(128-image.fsh)/2;
                    }else{
                        image.fsh=128;
                        image.fsy=0;
                        image.fsw=w*128/h;
                    }
                    fsw+=30+image.fsw;
                    
                    let maxlevel=0;
                    while(w>1 || h>1){
                        w=(w+1)>>1;
                        h=(h+1)>>1;
                        maxlevel++;
                    }
                    image.maxlevel=maxlevel;
                    images.push(image);
                }
                fsw-=30;
                console.log(Date.now()-start,"Got DZIs");
                atlas=await atlas;
                atlas.blob=atlas.encoding===1?new Uint8Array(atlas.blob):new Uint16Array(atlas.blob);
                console.log(Date.now()-start,"Got atlas");
                console.log(atlas);
                document.getElementById("atlas").innerText=atlas.name;
                
                for(let image of images){
                    if(image.hasOwnProperty("ouv"))
                        image.anchored=true;
                    image.snr=parseInt(image.name.match(/_s(\d+)/)[1]);
                }
                propagate();
                
                //stripidx=Math.min(images.length-1,(images.length>>1)+1);
                activateslice(Math.min(images.length-1,(images.length>>1)+1));
                strippos=images[stripidx].fsx-(window.innerWidth-images[stripidx].fsw)/2;
                console.log(images[stripidx]);
                console.log(strippos);
                
                ready=true;
                resize();
                console.log(images);
            }
            let ctrlw=300;
            let fstrip=128;
            let width;
            let mainh;
            let mainw;
            function resize(){
                let ctrl=document.getElementById("controls");
                let hsiz=document.getElementById("hsiz");
                let main=document.getElementById("main");
                let hsep=document.getElementById("hsep");
                let navi=document.getElementById("navi");
                let vsiz=document.getElementById("vsiz");
                let fstr=document.getElementById("filmstrip");
                
                let maincnv=document.getElementById("maincnv");
                let navicnv=document.getElementById("navicnv");
                let filmcnv=document.getElementById("filmcnv");

                if(fstrip>128)
                    fstrip=128;
                if(fstrip<0)fstrip=0;
                width=filmcnv.width=window.innerWidth;
        
                mainh=maincnv.height=navicnv.height=window.innerHeight-fstrip-vsiz.offsetHeight;
                ctrl.style.height=
                        hsiz.style.height=
                        main.style.height=
                        hsep.style.height=
                        navi.style.height=
                        vsiz.style.top=mainh+"px";
                nfact=(mainh-10-10)/(atlas.zdim+atlas.zdim+atlas.xdim);
                navw=navicnv.width=nfact*Math.max(atlas.ydim,atlas.xdim);
                ctrl.style.width=hsiz.style.left=ctrlw+"px";
                navi.style.left=(width-navw)+"px";
                navi.style.width=navw+"px";
                hsep.style.left=(width-navw-hsep.offsetWidth)+"px";
                main.style.left=(ctrlw+hsiz.offsetWidth)+"px";
                mainw=maincnv.width=width-ctrlw-navw-hsiz.offsetWidth-hsep.offsetWidth;
                main.style.width=mainw+"px";
                vsiz.style.width=fstr.style.width=width+"px";
                fstr.style.top=(window.innerHeight-fstrip)+"px";
                filmcnv.height=fstrip;
                fstr.style.height=fstrip+"px";
                drawX("maincnv");
                drawX("navicnv");
                drawX("filmcnv");
                drawstrip();
                drawimage();
                drawnavi();
            }
            function drawX(id){
                let cnv=document.getElementById(id);
//                let parent=cnv.parentNode;
//                cnv.width=parent.offsetWidth;
//                cnv.height=parent.offsetHeight;
                let ctx=cnv.getContext("2d");
                ctx.clearRect(0,0,cnv.width,cnv.height);
                ctx.lineWidth=1;
                ctx.strokeStyle="red";
                ctx.strokeRect(0.5,0.5,cnv.width-1,cnv.height-1);
                ctx.beginPath();
                ctx.moveTo(0,0);
                ctx.lineTo(cnv.width,cnv.height);
                ctx.moveTo(0,cnv.height);
                ctx.lineTo(cnv.width,0);
                ctx.stroke();
            }
            
            let strippos;
            let stripidx;
//            let stripdrawing=false;
//            let stripredraw=false;
//            async function drawstrip(){
            function drawstrip(){
                if(!ready)return;
//                stripredraw=false;
//                if(stripdrawing){
//                    stripredraw=true;
//                    return;
//                }
                
                if(strippos>fsw-width)strippos=fsw-width;
                if(strippos<0)strippos=0;
                let current=images[stripidx];
                
                let cnv=document.getElementById("filmcnv");
                let ctx=cnv.getContext("2d");
                ctx.clearRect(0,0,width,fstrip);
                ctx.fillStyle="black";
                
                let alpha=document.getElementById("stripalpha").valueAsNumber;
//                if(alpha>0){ // todo: rate limit
                let so=document.getElementById("stripoutline");
                so.disabled=alpha<100;
                if(so.disabled)
                    alpha=-alpha;
                else
                    alpha=parseInt(so.value.substring(1),16);
                
                for(let image of images)
                    if(image.fsx-strippos>=-image.fsw && image.fsx-strippos<=width){
                        if(image===current){
                            ctx.fillStyle="orange";
                            ctx.fillRect(image.fsx-strippos-10,0,image.fsw+20,128);
                            ctx.fillStyle="black";
                        }
                        if(image.hasOwnProperty("icon")){
                            ctx.drawImage(image.icon,image.fsx-strippos,image.fsy,image.fsw,image.fsh);
                            if(alpha!==0 || !so.disabled)
                            drawslice(image.ouv,ctx,image.fsx-strippos,image.fsy,image.fsw,image.fsh,alpha);
                        }
                        else{
                            ctx.fillRect(image.fsx-strippos,image.fsy,image.fsw,image.fsh);
                            drawslice(image.ouv,ctx,image.fsx-strippos,image.fsy,image.fsw,image.fsh,-100);
                            let w=image.width;
                            let h=image.height;
                            let t=image.tilesize;
                            let l=image.maxlevel;
                            while(w>t || h>t){
                                w=(w+1)>>1;
                                h=(h+1)>>1;
                                l--;
                            }
                            let i=document.createElement("img");
                            i.onload=()=>{image.icon=i;drawstrip();};
                            i.crossOrigin="anonymous";
                            i.src=image.base+l+"/0_0."+image.format;
                        }
                    }
                
//                stripdrawing=false;
//                if(stripredraw)
//                    drawstrip();
            }
            function stripscroll(event){
                strippos+=event.deltaY;
                drawstrip();
            }
            function strippick(event){
                if(!ready)return;
                let x=event.offsetX+strippos;
                for(let i=0;i<images.length;i++){
                    let image=images[i];
                    if(image.fsx<=x && x<image.fsx+image.fsw){
                        activateslice(i);
                        break;
                    }
                }
            }

            let ouv;
            function activateslice(idx){
                stripidx=idx;
                marker=false;
                let image=images[idx];
                document.getElementById("image").innerText=image.name+"\n"+image.width+" x "+image.height;
                ouv=image.ouv.slice();
                drawimage();
                drawstrip();
                drawnavi();
//                drawcut();
            }
            function store(){
                if(!ready)return;
                let image=images[stripidx];
                image.ouv=ouv.slice();
                image.anchored=true;
                propagate();
                drawstrip();
            }
            function restore(){
                if(!ready)return;
                ouv=images[stripidx].ouv.slice();
                drawimage();
                drawnavi();
            }
            
            let mainimg=false;
            let marker=false;
            async function drawimage(){
                if(!ready)return;
                let idx=stripidx;
                let {width,height,tilesize,overlap,format,base,maxlevel,fullcanvas/*,ouv*/}=images[idx];
                let x=0,y=0;
                let w=mainw,h=mainh;
                if(w/h<width/height){
                    h=Math.floor(w*height/width);
                    y=(mainh-h)/2;
                }else{
                    w=Math.floor(h*width/height);
                    x=(mainw-w)/2;
                }
                mainimg={x,y,w,h};
                while(width>w*2 && height>h*2){
                    maxlevel--;
                    width=(width+1)>>1;
                    height=(height+1)>>1;
                }
                if(!fullcanvas || fullcanvas.width<w || fullcanvas.height<h){
                fullcanvas=document.createElement("canvas");
                let ctx=fullcanvas.getContext("2d");
                fullcanvas.width=width;
                fullcanvas.height=height;
                let xtiles=Math.ceil(width/tilesize);
                let ytiles=Math.ceil(height/tilesize);
                let loads=[];
                let wcopy=mainw;
                let hcopy=mainh;
                //let xx=x,yy=y;
                for(let x=0;x<xtiles;x++)
                    for(let y=0;y<ytiles;y++)
                        loads.push(new Promise((resolve,reject)=>{
                            let tile=document.createElement("img");
                            tile.onerror=reject;
                            tile.onload=()=>{
                                ctx.drawImage(tile,x*tilesize-(x===0?0:overlap),y*tilesize-(y===0?0:overlap));
                                //if(wcopy===mainw && hcopy===mainh && idx===stripidx)
                                //    document.getElementById("maincnv").getContext("2d").drawImage(fullcanvas,xx,yy,w,h);
                                resolve();
                            };
                            tile.crossOrigin="anonymous";
                            tile.src=base+maxlevel+"/"+x+"_"+y+"."+format;
                        }));
                await Promise.all(loads);
                if(wcopy!==mainw || hcopy!==mainh)
                    return;
                images[idx].fullcanvas=fullcanvas;
                if(idx!==stripidx)
                    return;
            }
                ctx=document.getElementById("maincnv").getContext("2d");
                ctx.clearRect(0,0,mainw,mainh);
                ctx.drawImage(fullcanvas,x,y,w,h);
                let alpha=document.getElementById("mainalpha").valueAsNumber;
                if(alpha>0){ // todo: rate limit
                    let mo=document.getElementById("mainoutline");
                    mo.disabled=alpha<100;
                    if(mo.disabled)
                        alpha=-alpha;
                    else
                        alpha=parseInt(mo.value.substring(1),16);
                    drawslice(ouv,ctx,x,y,w,h,alpha);
                    if(marker){
                        ctx.strokeStyle="black";
                        ctx.lineWidth=2;
                        ctx.beginPath();
                        switch(marker.type){
                            case "cross":
                                ctx.moveTo(x+w*marker.x-10,y+h*marker.y);
                                ctx.lineTo(x+w*marker.x+10,y+h*marker.y);
                                ctx.moveTo(x+w*marker.x,y+h*marker.y-10);
                                ctx.lineTo(x+w*marker.x,y+h*marker.y+10);
                                break;
                            case "vscale":
                                ctx.moveTo(0,y+h*marker.y);
                                ctx.lineTo(mainw,y+h*marker.y);
    //                            ctx.moveTo(0,mainy);
    //                            ctx.lineTo(mainw,mainy);
                                break;
                            case "hscale":
                                ctx.moveTo(x+w*marker.x,0);
                                ctx.lineTo(x+w*marker.x,mainh);
//                                ctx.moveTo(mainx,0);
//                                ctx.lineTo(mainx,mainh);
                                break;
                            case "rotate":
                                ctx.moveTo(x+w*marker.x-5,y+h*marker.y);
                                ctx.lineTo(x+w*marker.x+5,y+h*marker.y);
                                ctx.moveTo(x+w*marker.x,y+h*marker.y-5);
                                ctx.lineTo(x+w*marker.x,y+h*marker.y+5);
                                ctx.stroke();
                                ctx.beginPath();
                                ctx.arc(x+w*marker.x,y+h*marker.y,10,3*Math.PI/4,Math.PI/4);
                                break;
                        }
                        ctx.stroke();
                    }
                }
            }
            
            let navw=0;
            let nfact;
            let zfact;
            let xfact;
            let midpoint;
            function drawnavi(){
                if(!ready)return;
                let {xdim,ydim,zdim}=atlas;
                let cnv=document.getElementById("navicnv");
                let ctx=cnv.getContext("2d");
                ctx.clearRect(0,0,cnv.width,cnv.height);
//                let nfact=(mainh-10-10)/(atlas.zdim+atlas.zdim+atlas.xdim);
                let points=[[0,0],[1,0],[1,1],[0,1],[0.5,0.5]].map(uv=>
                        [0,1,2].map(idx=>ouv[idx]+uv[0]*ouv[idx+3]+uv[1]*ouv[idx+6]));
//                let x=ouv[0]+(ouv[3]+ouv[6])/2;
//                let y=ouv[1]+(ouv[4]+ouv[7])/2;
//                let z=ouv[2]+(ouv[5]+ouv[8])/2;
                xfact=xdim*nfact;
                zfact=zdim*nfact;
                ctx.fillStyle="black";
                ctx.fillRect(0,0,navw,zfact);
                ctx.fillRect(0,zfact+10,navw,xfact);
                ctx.fillRect(navw-xfact,zfact+xfact+10+10,xfact,zfact);
                drawslice([points[4][0],ydim-1,zdim-1,
                           0,-ydim,0,
                           0,0,-zdim],ctx,0,0,navw,zfact,-100);
                drawslice([xdim-1,ydim-1,points[4][2],
                           0,-ydim,0,
                           -xdim,0,0],ctx,0,zfact+10,navw,xfact,-100);
                drawslice([0,points[4][1],zdim-1,
                           xdim,0,0,
                           0,0,-zdim],ctx,navw-xfact,zfact+xfact+10+10,xfact,zfact,-100);
                let npoints=points.map(p=>[p[0]*nfact,navw-p[1]*nfact,zfact-p[2]*nfact]);
                midpoint=npoints[4];
                
                ctx.lineWidth=2;
                
                ctx.beginPath();
                ctx.moveTo(npoints[0][1],npoints[0][2]);
                ctx.lineTo(npoints[1][1],npoints[1][2]);
                ctx.lineTo(npoints[2][1],npoints[2][2]);
                ctx.lineTo(npoints[3][1],npoints[3][2]);
                ctx.closePath();
                ctx.fillStyle="blue";
                ctx.globalAlpha=0.2;
                ctx.fill();
                ctx.globalAlpha=1;
                ctx.strokeStyle="yellow";
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(npoints[4][1],npoints[4][2],3,0,Math.PI*2);
                ctx.closePath();
                ctx.fillStyle="yellow";
                ctx.fill();

                ctx.beginPath();
                ctx.moveTo(npoints[0][1],xfact-npoints[0][0]+zfact+10);
                ctx.lineTo(npoints[1][1],xfact-npoints[1][0]+zfact+10);
                ctx.lineTo(npoints[2][1],xfact-npoints[2][0]+zfact+10);
                ctx.lineTo(npoints[3][1],xfact-npoints[3][0]+zfact+10);
                ctx.closePath();
                ctx.fillStyle="blue";
                ctx.globalAlpha=0.2;
                ctx.fill();
                ctx.globalAlpha=1;
                ctx.strokeStyle="yellow";
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(npoints[4][1],xfact-npoints[4][0]+zfact+10,3,0,Math.PI*2);
                ctx.closePath();
                ctx.fillStyle="yellow";
                ctx.fill();
                
                ctx.beginPath();
                ctx.moveTo(npoints[0][0]+navw-xfact,npoints[0][2]+zfact+10+xfact+10);
                ctx.lineTo(npoints[1][0]+navw-xfact,npoints[1][2]+zfact+10+xfact+10);
                ctx.lineTo(npoints[2][0]+navw-xfact,npoints[2][2]+zfact+10+xfact+10);
                ctx.lineTo(npoints[3][0]+navw-xfact,npoints[3][2]+zfact+10+xfact+10);
                ctx.closePath();
                ctx.fillStyle="blue";
                ctx.globalAlpha=0.2;
                ctx.fill();
                ctx.globalAlpha=1;
                ctx.strokeStyle="yellow";
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(npoints[4][0]+navw-xfact,npoints[4][2]+zfact+10+xfact+10,3,0,Math.PI*2);
                ctx.closePath();
                ctx.fillStyle="yellow";
                ctx.fill();
            }
            
            function drawcut(){
                
            }

            let drag=false;
            function mup(event){
                if(drag){
                    drag=false;
                    if(marker){
                        marker.type="cross";
                        drawimage();
                    }
                }
            }
            function hresize(event){
                drag={type:"hresize",x:event.target.offsetWidth-event.offsetX};
            }
            function vresize(event){
                drag={type:"vresize",y:event.target.offsetHeight-event.offsetY};
            }
            function range(v,c,r){
                return v>=c-r && v<=c+r;
            }
            function ndrag(event){
//                ctx.arc(npoints[4][1],npoints[4][2],3,0,Math.PI*2);
//                ctx.arc(npoints[4][1],npoints[4][0]+zfact+10,3,0,Math.PI*2);
//                ctx.arc(npoints[4][0]+navw-xfact,npoints[4][2]+zfact+10+xfact+10,3,0,Math.PI*2);
                drag={x:event.offsetX,y:event.offsetY};
                if(range(event.offsetX,midpoint[1],5) && range(event.offsetY,midpoint[2],5)){
                    drag.type="sdrag";
                }else if(range(event.offsetX,midpoint[1],5) && range(event.offsetY,xfact-midpoint[0]+zfact+10,5)){
                    drag.type="hdrag";
                }else if(range(event.offsetX,midpoint[0]+navw-xfact,5) && range(event.offsetY,midpoint[2]+zfact+10+xfact+10,5)){
                    drag.type="cdrag";
                }else if(event.offsetY<zfact){
                    drag.type="srot";
                }else if(event.offsetY>zfact+10+xfact+10){
                    drag.type="crot";
                }else
                    drag.type="hrot";
            }

            let mainx,mainy;
            function mainmove(event){
                mainx=event.offsetX;
                mainy=event.offsetY;
            }
            function maindrag(event){
                drag={type:"mdrag",x:event.offsetX,y:event.offsetY};
            }
            function maindown(event){
                if(!marker || event.code==="Space")
                    marker={type:"cross",
                            x:(mainx-mainimg.x)/mainimg.w,
                            y:(mainy-mainimg.y)/mainimg.h};
                if(event.code==="Escape")
                    marker=false;
                if(event.code==="Space")
                    marker.type="cross";
                if(event.code==="ArrowUp" || event.code==="ArrowDown")
                    marker.type="vscale";
                if(event.code==="ArrowLeft" || event.code==="ArrowRight")
                    marker.type="hscale";
                if(event.code==="PageUp" || event.code==="PageDown")
                    marker.type="rotate";
                drawimage();
            }
            function mmove(event){
                if(!drag)return;
                let angles;
                switch(drag.type){
                    case "hresize":
                        ctrlw=event.clientX-drag.x;
                        resize();
                        return;
                    case "vresize":
                        fstrip=Math.max(0,window.innerHeight-event.clientY-drag.y);
                        resize();
                        return;
                    case "sdrag":
                        ouv[1]+=(drag.x-event.offsetX)/nfact;
                        ouv[2]+=(drag.y-event.offsetY)/nfact;
                        break;
                    case "hdrag":
                        ouv[1]+=(drag.x-event.offsetX)/nfact;
                        ouv[0]+=(drag.y-event.offsetY)/nfact;
                        break;
                    case "cdrag":
                        ouv[0]-=(drag.x-event.offsetX)/nfact;
                        ouv[2]+=(drag.y-event.offsetY)/nfact;
                        break;
                    case "srot":
                        angles=sincos(midpoint[1],midpoint[2],drag.x,drag.y,event.offsetX,event.offsetY);
                        decomp(ouv);
                        rot(ouv,4,5,angles);
                        rot(ouv,7,8,angles);
                        recomp(ouv);
                        break;
                    case "hrot":
                        angles=sincos(midpoint[1],xfact-midpoint[0]+zfact+10,drag.x,drag.y,event.offsetX,event.offsetY);
                        decomp(ouv);
                        rot(ouv,4,3,angles);
                        rot(ouv,7,6,angles);
                        recomp(ouv);
                        break;
                    case "crot":
                        angles=sincos(midpoint[0]+navw-xfact,midpoint[2]+zfact+10+xfact+10,event.offsetX,event.offsetY,drag.x,drag.y);
                        decomp(ouv);
                        rot(ouv,3,5,angles);
                        rot(ouv,6,8,angles);
                        recomp(ouv);
                        break;
                    case "mdrag":
                        if(!marker || marker.type==="cross"){
                            for(let i=0;i<3;i++){
                                ouv[i]+=ouv[i+3]*(drag.x-event.offsetX)/mainimg.w;
                                ouv[i]+=ouv[i+6]*(drag.y-event.offsetY)/mainimg.h;
                            }
                        }else{
                            switch(marker.type){
                                case "vscale":
                                    let vfactor=((drag.y-mainimg.y)-mainimg.h*marker.y)/((event.offsetY-mainimg.y)-mainimg.h*marker.y);
                                    for(let i=0;i<3;i++){
                                        ouv[i]+=ouv[i+6]*marker.y;
                                        ouv[i+6]*=vfactor;
                                        ouv[i]-=ouv[i+6]*marker.y;
                                    }
                                    break;
                                case "hscale":
                                    let hfactor=((drag.x-mainimg.x)-mainimg.w*marker.x)/((event.offsetX-mainimg.x)-mainimg.w*marker.x);
                                    for(let i=0;i<3;i++){
                                        ouv[i]+=ouv[i+3]*marker.x;
                                        ouv[i+3]*=hfactor;
                                        ouv[i]-=ouv[i+3]*marker.x;
                                    }
                                    break;
                                case "rotate":
                                    let angles=sincos(mainimg.x+mainimg.w*marker.x,
                                                      mainimg.y+mainimg.h*marker.y,
                                                      drag.x,drag.y,event.offsetX,event.offsetY);
                                    for(let i=0;i<3;i++){
                                        ouv[i]+=ouv[i+3]*marker.x+ouv[i+6]*marker.y;
//                                        ouv[i+3]/=mainimg.w;
//                                        ouv[i+6]/=mainimg.h;
//                                        ouv[i]-=(ouv[i+3]+ouv[i+6])/2;
                                    }
//                                    decomp(ouv);
                                    let u=ouv.slice(3,6);
                                    let v=ouv.slice(6);
                                    for(let i=0;i<3;i++){
                                        ouv[i+3]=u[i]*angles[1]-v[i]*angles[0];
                                        ouv[i+6]=u[i]*angles[0]+v[i]*angles[1];
                                    }
//                                    u=mainimg.w/ouv[9];
//                                    v=mainimg.h/ouv[10];
////                                    u=ouv[9];
////                                    v=ouv[10];
//                                    ouv[9]=mainimg.w/(u*angles[1]-v*angles[0]);
//                                    ouv[10]=mainimg.h/(u*angles[0]+v*angles[1]);
//                                    recomp(ouv);
                                    for(let i=0;i<3;i++){
//                                        ouv[i]+=(ouv[i+3]+ouv[i+6])/2;
//                                        ouv[i+3]*=mainimg.w;
//                                        ouv[i+6]*=mainimg.h;
                                        ouv[i]-=ouv[i+3]*marker.x+ouv[i+6]*marker.y;
                                    }
                                    
                            }
                        }
                        break;
                }
                drawnavi();
                drawimage();
                drag.x=event.offsetX;
                drag.y=event.offsetY;
            }
            function propagate(){
                let anchoring=false;
                for(let image of images)
                    if(image.anchored===true){
                        if(anchoring===false)
                            anchoring=image;
                        else
                            anchoring=true;
                    }
                if(anchoring===false){
                    let keyslice=images[Math.min(images.length-1,(images.length>>1)+1)];
                    let ouv=[0,atlas.ydim/2,atlas.zdim-1,
                            atlas.xdim,0,0,
                            0,0,-atlas.zdim
                        ];
                    decomp(ouv,keyslice.width,keyslice.height);
                    for(let image of images)
                        recomp(image.ouv=ouv.slice(),image.width,image.height);

                }
                else if(anchoring!==true){
                    let ouv=anchoring.ouv;
                    decomp(ouv,anchoring.width,anchoring.height);
                    for(let image of images)
                        recomp(image.ouv=ouv.slice(),image.width,image.height);
                }
                else{
        let linregs=[];
        for(let i=0;i<11;i++)
            linregs.push(new LinReg());
        for(let image of images)
                    if(image.anchored){
                let ouv=image.ouv;
                decomp(ouv,image.width,image.height);
                for(let i=0;i<ouv.length;i++)
                    linregs[i].add(image.snr,ouv[i]);
            }
        let clearfirst=false;
        let clearlast=false;
                if(!images[0].anchored){
                    let image=images[0];
                        let w=[];
                    for(let linreg of linregs)
                        w.push(linreg.get(image.snr));
                    orthonormalize(w);
                    image.ouv=w;
                    image.anchored=clearfirst=true;
                }
                if(!images[images.length-1].anchored){
                    let image=images[images.length-1];
                        let w=[];
                    for(let linreg of linregs)
                        w.push(linreg.get(image.snr));
                    orthonormalize(w);
                    image.ouv=w;
                    image.anchored=clearlast=true;
                }
                let start=0;
                while(start<images.length-1){
                    let end=start+1;
                    while(!images[end].anchored)
                        end++;
                    if(end>start+1){
                    let si=images[start];
                    let ssnr=si.snr;
                    let souv=si.ouv;
                    let ei=images[end];
                    let esnr=ei.snr;
                    let eouv=ei.ouv;
                    let linints=[];
                    for(let i=0;i<11;i++)
                        linints.push(new LinInt(ssnr,souv[i],esnr,eouv[i]));
                    for(let j=start+1;j<end;j++){
                        let image=images[j];
                        let snr=image.snr;
                        let w=[];
                        for(let linint of linints)
                            w.push(linint.get(snr));
                        orthonormalize(w);
                        image.ouv=w;
                    }                    
                }
                    start=end;
                }
                if(clearfirst)images[0].anchored=false;
                if(clearlast)images[images.length-1].anchored=false;
                for(let image of images)
                    recomp(image.ouv,image.width,image.height);
                }
                
            }
            async function save(){
                for(let i=0;i<images.length;i++){
                    let image=images[i];
                    if(image.anchored)
                        series.sections[i].ouv=image.ouv;
                    else
                        delete series.sections[i].ouv;
                }
                let upload = await fetch("bucket.php?put=true&filename=" + args.get("filename")).then(response => response.json());
                if (!upload.hasOwnProperty("url")) {
                    alert("Can't save: "+JSON.stringify(upload));
                    return;
                }
                await fetch(upload.url, {
                    method: "PUT",
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(series)
                });
            }
        </script>
    </head>
    <body onload="startup()" onmouseup="mup(event)" onmousemove="mmove(event)">
        <div id="controls">
            <span id="image"><br></span><br>
            <span id="atlas"></span>
            <hr>
            <button onclick="store()">Store</button><button onclick="restore()">Restore</button>
            <br>
            Overlay:<br>
            <input id="mainalpha" type="range" min="0" max="100" step="1" value="100" oninput="drawimage()">
            <input id="mainoutline" type="color" value="#0000FF" oninput="drawimage()">
            <br>
            Filmstrip:<br>
            <input id="stripalpha" type="range" min="0" max="100" step="1" value="100" oninput="drawstrip()">
            <input id="stripoutline" type="color" value="#0000FF" oninput="drawstrip()">
            <br>
            <br>
            <button onclick="save()">Save to bucket</button>
        </div>
        <div id="hsiz" class="hsep" onmousedown="hresize(event)"></div>
        <div id="main">
            <canvas id="maincnv" tabindex="1"
                    onmousedown="maindrag(event)"
                    onmousemove="mainmove(event)"
                    onkeydown="maindown(event)"
                    onmouseover="event.target.focus()"
                    onmouseout="event.target.blur()"></canvas>
        </div>
        <div id="hsep" class="hsep"></div>
        <div id="navi">
            <canvas id="navicnv" onmousedown="ndrag(event)"></canvas>
        </div>
        <div id="vsiz" onmousedown="vresize(event)"></div>
        <div id="filmstrip">
            <canvas id="filmcnv" onclick="strippick(event)" onmousewheel="stripscroll(event)"></canvas>
        </div>
    </body>
</html>
